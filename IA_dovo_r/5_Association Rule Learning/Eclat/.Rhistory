if (x > 3){
y = 10
} else {
y = 0
}
# IF & ELSe#
x = rand()
# IF & ELSe#
x = randu()
# IF & ELSe#
x = randu(1)
# IF & ELSe#
x = runif(min = 0, max = 10)
# IF & ELSe#
x = runif(1, min = 0, max = 10)
if (x > 3){
y = 10
} else {
y = 0
}
# IF & ELSe#
x = runif(1, min = 0, max = 10)
if (x > 3){
y = 10
} else {
y = 0
}
# IF & ELSe#
x = runif(1, min = -5, max = 5)
if (x > 3){
y = 10
} else {
y = 0
}
# IF & ELSe#
x = runif(1, min = -5, max = 5)
if (x > 3){
y = 10
} else {
y = 0
}
# IF & ELSe#
x = runif(1, min = -5, max = 5)
if (x > 3){
y = 10
} else {
y = 0
}
# IF & ELSe#
x = runif(1, min = -5, max = 5)
# IF & ELSe#
x = runif(1, min = -5, max = 5)
# IF & ELSe#
x = runif(1, min = -5, max = 5)
if (x > 3){
y = 10
} else {
y = 0
}
# IF & ELSe#
x = runif(1, min = 0, max = 6)
if (x > 3){
y = 10
} else {
y = 0
}
# IF & ELSe#
x = runif(1, min = 0, max = 6)
# IF & ELSe#
x = runif(1, min = 0, max = 6)
if (x > 3){
y = 10
} else {
y = 0
}
y = if(x>3){
10
}else{
0
}
x = runif(1, min = 0, max = 6)
# Diferent ways
y = if(x>3){
10
}else{
0
}
for(i in 1:10){
print(i)
}
x = c("a", "b", "c", "d")
for(i in 1:4){
print(x[i])
}
for (i in seq_along(x)) {
pint(x[i])
}
for (i in seq_along(x)) {
print(x[i])
}
for (letter in x){
print(letter)
}
for(i in 1:4) print(x[i])
x = matrix(1:6, nrow = 2, ncol = 3)
x = matrix(1:6, 2, 3)
x = matrix(1:6, 2, 3)
for (i in seq_len(nrow(x))){
for(j in seq_len(ncol(x))){
print(x[i,j])
}
}
count = 0
while (count < 10) {
print(count)
count =+ 1
}
while (count < 10) {
print(count)
count = count + 1
}
count ==+ 1
count =+ 1
while (count < 10) {
print(count)
count =+ 1
}
z = 5
while(z >= 3 && z <= 10){
print(z)
coin = rbinom(1,1, 0.5)
if (coin == 1){
z = z + 1
} else {
z = z -1
}
}
x = 1
tol = 1e-8
x = 1
tol = 1e-8
repeat{
x1 = computeEstimate()
if(abs(x1 - x0) < tol){
break
}else {
x0 <- x1
}
}
??computeEstimate
compute.es
compute.es()
??compute.es
install.packages("compute.es")
library("compute.es")
# REPEAT, NEXT, BREAKE #
# repeat initiates an infinite loop. these are not commonly used in stats
library("compute.es")
x1 =  computeEsimate()
x = 1
tol = 1e-8
repeat{
x1 = runif(1, min = 0, max = 6)
if(abs(x1 - x0) < tol){
break
}else {
x0 <- x1
}
}
# REPEAT, NEXT, BREAKE #
# repeat initiates an infinite loop. these are not commonly used in stats
x0 = 1
tol = 1e-8
repeat{
x1 = runif(1, min = 0, max = 6)
if(abs(x1 - x0) < tol){
break
}else {
x0 <- x1
}
}
x0 = 1
tol = 2
repeat{
x1 = runif(1, min = 0, max = 6)
if(abs(x1 - x0) < tol){
break
}else {
x0 <- x1
}
}
for(i in 1:100){
if(i <= 20) {
#Skip the firts 20 interations
next
}
print(i)
}
add2(3,5)
add2 = function(x, y) {
x + y
}
add(2,3)
add2(2,3)
above10 <- function(x, y){
use = x > y
x[use]
above10 <- function(x, y){
use = x > y
x[use]
}
above <- function(x, n){
use = x > n
x[use]
}
x = 1:20
abive(x, 3)
above(x, 3)
columnmean <- function(y){
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
means[i] = mean(y[, i])
}
means
}
columnmean(airquality)
columnmean <- function(y, na.exclude = TRUE){
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
means[i] = mean(y[, i])
}
means
}
columnmean(airquality)
columnmean <- function(y, na.exclude = TRUE){
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
means[i] = mean(y[, i], na.rm = TRUE)
}
means
}
columnmean(airquality)
cube <- function(x, n) {
x^3
}
cube(3)
x <- 1:10
if(x > 5) {
x <- 0
}
x <- 1:10
if(x > 5) {
x <- 0
}
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
z= 10
f(3)
x <- 5
y <- if(x < 3) {
NA
} else {
10
}
h <- function(x, y = NULL, d = 3L) {
z <- cbind(x, d)
if(!is.null(y))
z <- z + y
else
z <- z + f
g <- x + y / z
if(d == 3L)
return(g)
g <- g + 10
g
}
setwd("~/")
setwd("E:/Archivos/Proyectos personales/Curso IA R - Udemy/IA_dovo_r/5_Association Rule Learning/Eclat")
library("arules")
library("arulesViz")
dataset = read.transactions("Market_Basket_Optimisation.csv",
sep = ",", rm.duplicates = TRUE,
header = FALSE)
summary(dataset)
itemFrequencyPlot(dataset, topN = 20)
# Train algorithm apriori
rules = eclat(data = dataset, parameter = list(support = 0.004, minlen = 0.2))
itemFrequencyPlot(dataset, topN = 10)
# Train algorithm apriori
rules = eclat(data = dataset, parameter = list(support = 0.004, minlen = 0.2))
# Train algorithm apriori
rules = eclat(data = dataset, parameter = list(support = 0.004, minlen = 2))
#Data vis
inspect(sort(rules, by = "lift")[1:10])
#Data vis
inspect(sort(rules, decreasing)
#Data vis
inspect(sort(rules, decreasing))
#Data vis
inspect(x = rules)
plot(rules, method = "graph", engine = "htmlwidget")
#Data vis
inspect(x = rules, descentDetails())
#Data vis
inspect(x = rules, descentDetails
#Data vis
inspect(rules)
#Data vis
inspect(sort(rules, by = "support")[1:10])
x = list(a = 1:10, b = rnorm(20))
lapply(x, mean)
x = list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean)
lapply(x, runif)
x = 1:4
lapply(x, runif)
lapply(x, runifm, min = 0, max = 20)
lapply(x, runif, min = 0, max = 20)
sapply(x, mean)
# sapply
x = list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
sapply(x, mean)
# apply #
x = matrix(rnorm(200), 20, 10)
apply(x, 2, mean)
apply(x, 1, mean)
apply(x, 1, mean) # 1 = preserve all the rows
apply(x, 1, sim) # 1 = preserve all the rows
apply(x, 1, sum) # 1 = preserve all the rows
x = matrix(rnorm(200), 20, 10)
apply(x, quantile, probs = c(0.25, 0.50, 0.75))
apply(x, 1, quantile, probs = c(0.25, 0.50, 0.75))
# average matrix in array
a = array(rnorm(2 * 2 * 10), c(2, 2, 10))
apply(a, c(1, 2), mean)
# average matrix in array
a = array(rnorm(2 * 2 * 10), c(2, 2, 10))
apply(a, c(1, 2), mean)
rowMeans(a, dims = 2)
rowMeans(a, dims = 1
rowMeans(a, dims = 1
rowMeans(a, dims = 3
# mapply #
list(rep(1,4), rep(2,3), rep(3,2), rep(4,1)) # TEDIOUS!!!
mapply(rep, 1:4, 4:1)
# tapply #
x = c(rnorm(10), runif(10), rnorm(10, 1))
f = gl(3,10)
f
f = gl(3,10); f
tapply(x, f, mean)
# split #
x = c(rnorm(10), runif(10), rnorm(10, 1))
f = gl(3,10); f
split(x, f)
lapply(split(x,f), mean)
library(datasets)
head(airquality)
s = split(airquality, airquality$Month)
lapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")],
na.rm = T))
lapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")],
na.rm = T))
data(iris)
?iris
dataset = iris
dataset
s = split(dataset, dataset$Sepal.Length)
lapply(s, function(x) colMeans(x[, c("virginica")],
na.rm = T)) # List
View(s)
na.rm = T)) # List
mean(s)
a = subset(dataset$Sepal.Length, dataset$Species == "virginica")
a
mean(a)
View(dataset)
apply(iris[, 1:4], 1, mean)
apply(iris[, 1:4], 2, mean)
library(datasets)
data(mtcars)
?mtcars
tapply(mtcars$mpg, mtcars$cyl, mean)
apply(mtcars, 2, mean)
tapply(mtcars$cyl, mtcars$mpg, mean)
split(mtcars, mtcars$cyl)
mean(mtcars$mpg, mtcars$cyl)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
sapply(mtcars, cyl, mean)
sapply(mtcars, mtcars$cyl, mean)
sapply(mtcars, mtcars$cyl, mean)
sapply(mtcars, cyl, mean)
with(mtcars, tapply(mpg, cyl, mean))
abs(with(mtcars, tapply(mpg, cyl, mean)))
abs(26.66364, 15.10000)
abs(26.66364 - 15.10000)
debug(ls)
ls()
force(sorted)
Q
